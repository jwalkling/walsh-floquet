"""
Walsh-Series Expansion vs. Exact Floquet Solution
=================================================

This script compares:

    • the exact Floquet Hamiltonian of a driven single qubit, and
    • the Walsh-series analytic expansion (0th and 1st order)

for a drive composed of the Walsh functions **W₂** and **W₁₃**.  
It also exports a sampled **sequency-13 Walsh function** for plotting.

Two types of data are produced:

1. Walsh Function (Sequency = 13)
   --------------------------------------
   For N = 16 time subdivisions, the script extracts:

       • tvals : time indices (0 … 16)
       • W13   : sequency-13 Walsh function evaluated on all bins

   The last value is appended to ensure proper step-plot behavior.

2. Floquet-vs-Walsh Comparison
   --------------------------------------
   The exact Floquet Hamiltonian is computed as:

       HF(ω) = (i / T) log U(ω)

   where U(ω) is the single-period kick operator generated by the
   combined W₂ and W₁₃ drive.

   The Walsh-series approximations used are:

       Zeroth order:             H₀  =   h_z Z
       First-order correction:   H₀₁ =   h_z Z + (2π / (16 ω)) h_x h_y Z

   For each ω, the script computes:

       • errors_0  : |λ_min(HF − H₀)|
       • errors_01 : |λ_min(HF − H₀₁)|

   where λ_min denotes the lower of the two exact quasi-energies.

Scan parameters:

       ω ∈ [1, 10000] in steps of 5
       Physical parameters:  h_x=2, h_y=10, h_z=1

Output
------
The script saves:

    ../../data/processed/Walsh_series.pkl

containing:

    {
        "tvals":      array of time indices (0..16)
        "W13":        sequency-13 Walsh function samples
        "omegas":     scanned frequency values
        "errors_0":   zeroth-order Walsh-expansion errors
        "errors_01":  first-order Walsh-expansion errors
    }

These arrays are ready for direct plotting to compare convergence
of the analytic Walsh expansion to the exact Floquet solution.
"""

import os
import pickle
from pathlib import Path

import numpy as np

# =====================================================================
# Working directory and Walsh helper imports
# =====================================================================

p = Path.cwd()
os.chdir(p)
p = p.parent / "src"           # go up one level, then into src
os.chdir(p)


import sys
sys.path.append(str(p))
from walsh_floquet import *    # Walsh/Floquet helper library


# =====================================================================
# 1. Sequency-13 Walsh function
# =====================================================================

tvals = np.arange(0, 17, 1)            # N = 16 subdivisions → 17 step points
W13 = compute_seq_order_walsh(N=16)[13][1]
W13.append(-1)                         # extend for nicer step plotting


# =====================================================================
# 2. Full Floquet solution vs. Walsh-series expansion
# =====================================================================

# Model parameters
omegas = np.arange(1, 10000, 5.0)
hx = 2
hy = 10
hz = 1

# Error storage
errors_0 = []     # Zeroth-order error
errors_01 = []    # Zeroth + first-order error

for omega in omegas:

    # Exact Floquet Hamiltonian
    HF = 1.0j * logm(UF_W2_and_W13(hx, hy, hz, omega)) / (2 * np.pi) * omega

    # Walsh expansion
    H0  = hz * PAULI_Z
    H01 = hz * PAULI_Z + (2 * np.pi / (16 * omega)) * hx * hy * PAULI_Z

    # Differences
    Diff0  = HF - H0
    Diff01 = HF - H01

    # Lowest quasi-energy (absolute)
    E0  = np.linalg.eigh(Diff0)[0][0]
    E01 = np.linalg.eigh(Diff01)[0][0]

    errors_0.append(np.abs(E0))
    errors_01.append(np.abs(E01))


# =====================================================================
# SAVE RESULTS
# =====================================================================

filename = "walsh_series.pkl"
processed_path = Path("..") / ".." / "data" / "processed"
os.makedirs(processed_path, exist_ok=True)
save_path = processed_path / filename

to_save = {
    "tvals": tvals,
    "W13": W13,
    "omegas": omegas,
    "errors_0": errors_0,
    "errors_01": errors_01,
}

with open(save_path, "wb") as f:
    pickle.dump(to_save, f)

print("Saved data to:", save_path)


# --------------------------------------------------------------------------- #
# End of Script
# --------------------------------------------------------------------------- #
